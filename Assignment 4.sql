use sakila;
-- 1.Identify a table in the Sakila database that violates 1NF . Explain how you would normalize it to achieve 1NF.

-- --> In the Sakila database,  the "award" column in the "actor_award" table violates the First Normal Form (1NF), 
-- it might be because it contains a list of awards in a single cell. To normalize it and achieve 1NF, 
-- you should create a new table where each award is stored in a separate row.
-- like that ->
-- | actor_award_id |  actor_id    | first_name    | last_name | award    | last_update|
-- |----------------|--------------|---------------|-----------|----------|------------|
-- | 1              | Actor_id1    | Actor1        | Actor1    |award1    | update     |
-- | 2              | Actor_id1    | Actor1        | Actor1    |award2    | update     |
-- | 3              | Actor_id2    | Actor2        | Actor2    |award1    | update     |
-- | 4              | Actor_id2    | Actor2        | Actor2    |award3    | update     |
-- |....            |....          |....           |....       |....      |....        |



-- 2.Choose a table in Sakila and describe how you would determine whether it is in 2NF. If it violates 2NF, explain the steps to normalize it.

-- --> I think after 1NF the "actor_award" table need 2NF .
-- after 1NF the actor_award table look like this ->
-- | actor_award_id |  actor_id    | first_name    | last_name | award    | last_update| 
-- |----------------|--------------|---------------|-----------|----------|------------|
-- | 1              | Actor_id1    | Actor1        | Actor1    |award1    | update     | 
-- | 2              | Actor_id1    | Actor1        | Actor1    |award2    | update     | 
-- | 3              | Actor_id2    | Actor2        | Actor2    |award1    | update     | 
-- | 4              | Actor_id2    | Actor2        | Actor2    |award3    | update     | 
-- |....            |....          |....           |....       |....      |....        |
-- To achieve 2NF, we need to split the table into two tables: one for "award" and another actor_awards for cunect actor and award table.
-- we don't need actor information table because that's alrady have.

-- award table look like this ->
-- | award_id | award       |
-- |----------|-------------|
-- | 1        | Award1      |
-- | 2        | Award2      |
-- | 3        | Award3      |
-- | ...      | ...         |

-- and actor_award table look like this ->
-- | actor_id | award_id | last_update |
-- |----------|----------| -------     |
-- | 1        | 1        | update      |
-- | 1        | 2        | update      |
-- | 2        | 3        | update      |
-- | 2        | 1        | update      |
-- | ...      | ...      | ...         |




-- 3.Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.

-- 4.Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.

-- 5.CTE Basics>
-- Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor and film_actot table.

with film_count as 
(
select 
    actor_id , 
    count(film_id) as total_film 
       from film_actor 
	group by actor_id),
total_film as 
(
select 
      fc.actor_id , 
      concat(first_name , " " , last_name) as actor_name , 
          total_film from actor as a
           join film_count as fc 
                on a.actor_id = fc.actor_id ) 
  select * from total_film ;


-- 6.Recursive CTE>
-- Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the category table in Sakila.

-- 7.CTE with Joins>
-- Create a CTE that combines information from the film and langauge and tables to display the film title, language name, and rental rate.
with film_filter as 
(
select 
   film_id , 
       title , 
         language_id ,  
             rental_rate 
                  from film),
film_language as
(
select 
     ff.film_id , 
          ff.title, 
               l.name , 
                  ff.rental_rate 
                      from language as l 
                           join film_filter as ff 
                                on l.language_id = ff.language_id )
 select * from film_language;

-- 8.CTE for Aggregation>
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payment table.

with id_amount as
(
select 
   customer_id , 
     sum(amount) as total_amount 
        from payment 
        group by customer_id), 
name_amount as 
(
select 
	c.customer_id , 
       concat(first_name , " " , last_name) as customer_name , 
          ia.total_amount 
          from customer as c 
              join id_amount as ia 
              on c.customer_id = ia.customer_id)
select * from name_amount;

-- 9.CTE with Window Functions>
-- Utilize a CTE with a window function to rank films based on their rental duration from the film table.

 with film_rank as 
 (
 select 
        film_id , 
          title , 
          rental_duration , 
	   rank () over (order by rental_duration) as rental_rank 
              from film)
 select * from film_rank ;

-- 10.CTE and Filtering>
--  Create a CTE to list customers who have made more than two rentals, and the join this CTE with the table to retrieve additional customer details
 
 with rental_details as
   (
       select 
           customer_id ,
        count(rental_id) as total_rental 
                from rental 
		group by customer_id ),
   customer_details as 
   (
   select 
         rd.customer_id , 
             concat(first_name , " " , last_name) as customer_name , 
		rd.total_rental 
            from rental_details as rd 
        join customer as c 
             on rd.customer_id = c.customer_id 
                           where total_rental > 2)
       select * from customer_details;
       
-- 11.CTE for Date Calculations>
-- Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental tablea.

with new_rental as
(
select
     rental_id ,
      rental_date , 
        monthname(rental_date) as month from rental),
total_rental as 
(
select 
     month , 
      count(rental_id) as total_count 
     from new_rental group by month)
select * from total_rental;

-- 12.CTE for Pivot Operations>
-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in separate columns for different payment methods.

-- 13.CTE and Self-Join>
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.
with actorID_table as
(
select 
        a.actor_id as actor_idA ,
              b.actor_id as actor_idB ,
      a.film_id 
          from film_actor a , film_actor b 
     where a.actor_id <> b.actor_id and
    a.film_id = b.film_id) ,
    actorsA as 
    (
    select 
          aa.actor_idA ,
              concat(a.first_name , " " , a.last_name) as name , 
              aa.actor_idB ,
                aa.film_id ,
                        f.title 
                from actorID_table as aa 
			join actor as a 
				on aa.actor_idA = a.actor_id 
			join film as f 
                on aa.film_id = f.film_id ) ,
    actorsB as
    (
    select
           a1.actor_idA ,
                    a1.name , 
               a1.actor_idB, 
			concat(a2.first_name , " " , a2.last_name) as name_2 ,
            a1.film_id ,
		a1.title 
               from actorsA as a1 
		join actor as a2 
                   on a1.actor_idB = a2.actor_id)
    select * from actorsB ;
-- 14.CTE for Recursive Search>
-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reportes_to column.